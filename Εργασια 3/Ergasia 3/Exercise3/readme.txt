Για την δημιουργία του εκτελέσιμου το οποίο δείχνει
τις δυνατότητες της βιβλιοθήκης BF, τρέξτε την εντολή:

make sort;

Για να τρέξετε το εκτελέσιμο:

./build/sort_main



Βιβλιοθήκη SORT_

1. bool shouldSwap(Record* rec1, Record* rec2)

Αυτή η συνάρτηση καθορίζει εάν δύο εγγραφές θα πρέπει να ανταλλαχθούν με βάση τα ονόματα και τα επώνυμα τους.
Συγκρίνει τα δύο ονόματα και αν το όνομα του rec1 είναι μεγαλύτερο από του rec2 τότε επιστρεφει true, 
αν τα όνοματα είναι τα ίδια τοτε συγκρίνουμε τα επώνυμα, διαφορετικά τυπώνει false.

2. void sort_Chunk(CHUNK* chunk)

Αυτή η συνάρτηση εφαρμόζει τον αλγόριθμο ταξινόμησης (bubble sort) μέσα σε κάθε συρμό. 
Χρησιμοποιεί τη συνάρτηση shouldSwap για να συγκρίνει και να αναδιατάσσει τις εγγραφές εντός του κομματιού.

3. void sort_FileInChunks(int file_desc, int numBlocksInChunk)

Αυτή η συνάρτηση ταξινομεί ένα αρχείο σωρού σε συρμούς. Διατρέχει τους συρμούς  στο αρχείο,
εφαρμόζοντας τη συνάρτηση sort_Chunk για να ταξινομήσει τις εγγραφές εντός κάθε συρμού.

------------------------------------------------------------------------------------------------------------------------------------------------

Βιβλιοθήκη MERGE_

void merge(int input_FileDesc, int chunkSize, int bWay, int output_FileDesc)

Δημιουργούμε ένα iterator για τη διαχείριση της εισαγωγικής αρχής, μνήμη για τον πίνακα συρμών, 
τις εγγραφές που θα συγχωνευτούν, και τους επαναληπτικούς δείκτες των εγγραφών.
Κάνουμε αρχικοποίηση των επαναληπτικών δεικτών των εγγραφών για κάθε συρμό.
Μετά έχουμε ένα βρόχο συγχώνευσης όπου αρχικοποιούμε μια μεταβλητή και έπειτα κάνουμε επανάληψη
μέσω των δεικτών για εύρεση της ελάχιστης εγγραφής, η οποία θα επιστρέψουμε στο αρχείο εξόδου. 
Μετά κάνουμε έναν ελεγχο αν ο συρμός της ελάχιστης εγγραφής έχει εξαντληθεί, 
αν ναι τότε παίρνουμε τον επόμενο συρμό για τον εξαντλημένο επαναλήπτη. 
Αλλιώς ενημερώνουμε την τρέχουσα εγγραφή από το αντίστοιχο συρμό και άν δεν υπάρχει άλλη εγγραφή, αφαιρουμε τον συρμό από τη συγχώνευση.
Τέλος κάνουμε έναν έλεγχο αν οι συρμοί έχουν τελειώσει έτσι ώστε να τερματίσει ο βρόχος και κάνουμε απελευθέρωση μνήμης.

------------------------------------------------------------------------------------------------------------------------------------------------

Βιβλιοθήκη CHUNK_

1. CHUNK_GetNext(CHUNK_Iterator *iterator,CHUNK* chunk);

Γίνεται έλεγχος αν έχει φτάσει στο τέλος του αρχείου, αν όχι τότε υπολογίζει τον 
τελευταίο έγκυρο αριθμό block στο αρχείο και ορίζουμε τα πεδία CHUNK με τις σωστές τιμές 
Μετά ενημερώνουμε τον τρέχοντα δείκτη για το επόμενο CHUNK και
επιστρέφει 0 αν όλα ολοκληρώθηκαν με επιτυχία.

2. int CHUNK_GetIthRecordInChunk(CHUNK* chunk,  int i, Record* record);

Αρχικά κάνουμε έναν έλεγχο αν ο δείκτης η είναι έγκυρος. Αν είναι τότε υπολογίζουμε 
το block και τον δείκτη της εγγραφής μέσα στο block, λαμβάνουμε την εγγραφή από τον υπολογισμένο τόπο.
Τέλος επιστρέφουμε 0 αν όλα ολοκληρώθηκαν με επιτυχία.

3. int CHUNK_UpdateIthRecord(CHUNK* chunk,  int i, Record record);

Το ίδιο με την από πάνω απλά αντι να λαμβανουμε ενημερώνουμε την εγγραφή από τον υπολογισμένο τόπο.

4. void CHUNK_Print(CHUNK chunk);

Εκτυπώνουμε τα block από το οποίο ξεκινάει το CHUNK μέχρι το τέλος του και για κάθε εγγραφή, εκτυπώνουμε τα πεδία της.

5. CHUNK_RecordIterator CHUNK_CreateRecordIterator(CHUNK *chunk);

Ορίζουμε τον τρέχοντα αριθμό block και τον δείκτη της εγγραφής.

6. int CHUNK_GetNextRecord(CHUNK_RecordIterator *iterator,Record* record);

Αρχικά ελέγχουμε αν ο δείκτης έχει φτάσει στο τέλος του CHUNK, 
λαμβάνουμε την επόμενη εγγραφή και ενημερώνουμε τον τρέχοντα αριθμό block και τον δείκτη της εγγραφής.